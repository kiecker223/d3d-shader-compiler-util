#include "d3d-shader-loader-types.h"



namespace LoaderPriv {

	EINPUT_ITEM_FORMAT ParseItemFormat(const std::string& ItemFormatStr)
	{
#define CHECK_ITEMFORMAT(x) if (ItemFormatStr == #x) { return x; }

		CHECK_ITEMFORMAT(INPUT_ITEM_FORMAT_FLOAT);
		CHECK_ITEMFORMAT(INPUT_ITEM_FORMAT_INT);
		CHECK_ITEMFORMAT(INPUT_ITEM_FORMAT_FLOAT2);
		CHECK_ITEMFORMAT(INPUT_ITEM_FORMAT_INT2);
		CHECK_ITEMFORMAT(INPUT_ITEM_FORMAT_FLOAT3);
		CHECK_ITEMFORMAT(INPUT_ITEM_FORMAT_INT3);
		CHECK_ITEMFORMAT(INPUT_ITEM_FORMAT_FLOAT4);
		CHECK_ITEMFORMAT(INPUT_ITEM_FORMAT_INT4);
		return INPUT_ITEM_FORMAT_FLOAT3;

#undef CHECK_ITEMFORMAT
	}

	bool ParseBool(std::string BoolStr)
	{
		if (BoolStr == "true")
			return true;
		if (BoolStr == "false")
			return false;
		return false;
	}

	EBLEND_STYLE ParseBlendStyle(const std::string& BlendStyleStr)
	{
#define CHECK_BLEND_STYLE(x)  if (BlendStyleStr == #x) { return x; }

		CHECK_BLEND_STYLE(BLEND_STYLE_ZERO);
		CHECK_BLEND_STYLE(BLEND_STYLE_ONE);
		CHECK_BLEND_STYLE(BLEND_STYLE_SRC_COLOR);
		CHECK_BLEND_STYLE(BLEND_STYLE_INV_SRC_COLOR);
		CHECK_BLEND_STYLE(BLEND_STYLE_SRC_ALPHA);
		CHECK_BLEND_STYLE(BLEND_STYLE_INV_SRC_ALPHA);
		CHECK_BLEND_STYLE(BLEND_STYLE_DEST_ALPHA);
		CHECK_BLEND_STYLE(BLEND_STYLE_INV_DEST_ALPHA);
		CHECK_BLEND_STYLE(BLEND_STYLE_DEST_COLOR);
		CHECK_BLEND_STYLE(BLEND_STYLE_INV_DEST_COLOR);
		CHECK_BLEND_STYLE(BLEND_STYLE_SRC_ALPHA_SAT);
		CHECK_BLEND_STYLE(BLEND_STYLE_BLEND_FACTOR);
		CHECK_BLEND_STYLE(BLEND_STYLE_INV_BLEND_FACTOR);
		CHECK_BLEND_STYLE(BLEND_STYLE_SRC1_COLOR);
		CHECK_BLEND_STYLE(BLEND_STYLE_INV_SRC1_COLOR);
		CHECK_BLEND_STYLE(BLEND_STYLE_SRC1_ALPHA);
		CHECK_BLEND_STYLE(BLEND_STYLE_INV_SRC1_ALPHA);
		return (EBLEND_STYLE)0;

#undef CHECK_BLEND_STYLE
	}

	EFORMAT ParseFormat(const std::string& FormatStr)
	{
#define CHECK_FORMAT(x) if (FormatStr == #x) { return x; }

		CHECK_FORMAT(FORMAT_UNKNOWN);
		CHECK_FORMAT(FORMAT_R32G32B32A32_TYPELESS);
		CHECK_FORMAT(FORMAT_R32G32B32A32_FLOAT);
		CHECK_FORMAT(FORMAT_R32G32B32A32_UINT);
		CHECK_FORMAT(FORMAT_R32G32B32A32_SINT);
		CHECK_FORMAT(FORMAT_R32G32B32_TYPELESS);
		CHECK_FORMAT(FORMAT_R32G32B32_FLOAT);
		CHECK_FORMAT(FORMAT_R32G32B32_UINT);
		CHECK_FORMAT(FORMAT_R32G32B32_SINT);
		CHECK_FORMAT(FORMAT_R16G16B16A16_TYPELESS);
		CHECK_FORMAT(FORMAT_R16G16B16A16_FLOAT);
		CHECK_FORMAT(FORMAT_R16G16B16A16_UNORM);
		CHECK_FORMAT(FORMAT_R16G16B16A16_UINT);
		CHECK_FORMAT(FORMAT_R16G16B16A16_SNORM);
		CHECK_FORMAT(FORMAT_R16G16B16A16_SINT);
		CHECK_FORMAT(FORMAT_R32G32_TYPELESS);
		CHECK_FORMAT(FORMAT_R32G32_FLOAT);
		CHECK_FORMAT(FORMAT_R32G32_UINT);
		CHECK_FORMAT(FORMAT_R32G32_SINT);
		CHECK_FORMAT(FORMAT_R32G8X24_TYPELESS);
		CHECK_FORMAT(FORMAT_D32_FLOAT_S8X24_UINT);
		CHECK_FORMAT(FORMAT_R32_FLOAT_X8X24_TYPELESS);
		CHECK_FORMAT(FORMAT_X32_TYPELESS_G8X24_UINT);
		CHECK_FORMAT(FORMAT_R10G10B10A2_TYPELESS);
		CHECK_FORMAT(FORMAT_R10G10B10A2_UNORM);
		CHECK_FORMAT(FORMAT_R10G10B10A2_UINT);
		CHECK_FORMAT(FORMAT_R11G11B10_FLOAT);
		CHECK_FORMAT(FORMAT_R8G8B8A8_TYPELESS);
		CHECK_FORMAT(FORMAT_R8G8B8A8_UNORM);
		CHECK_FORMAT(FORMAT_R8G8B8A8_UNORM_SRGB);
		CHECK_FORMAT(FORMAT_R8G8B8A8_UINT);
		CHECK_FORMAT(FORMAT_R8G8B8A8_SNORM);
		CHECK_FORMAT(FORMAT_R8G8B8A8_SINT);
		CHECK_FORMAT(FORMAT_R16G16_TYPELESS);
		CHECK_FORMAT(FORMAT_R16G16_FLOAT);
		CHECK_FORMAT(FORMAT_R16G16_UNORM);
		CHECK_FORMAT(FORMAT_R16G16_UINT);
		CHECK_FORMAT(FORMAT_R16G16_SNORM);
		CHECK_FORMAT(FORMAT_R16G16_SINT);
		CHECK_FORMAT(FORMAT_R32_TYPELESS);
		CHECK_FORMAT(FORMAT_D32_FLOAT);
		CHECK_FORMAT(FORMAT_R32_FLOAT);
		CHECK_FORMAT(FORMAT_R32_UINT);
		CHECK_FORMAT(FORMAT_R32_SINT);
		CHECK_FORMAT(FORMAT_R24G8_TYPELESS);
		CHECK_FORMAT(FORMAT_D24_UNORM_S8_UINT);
		CHECK_FORMAT(FORMAT_R24_UNORM_X8_TYPELESS);
		CHECK_FORMAT(FORMAT_X24_TYPELESS_G8_UINT);
		CHECK_FORMAT(FORMAT_R8G8_TYPELESS);
		CHECK_FORMAT(FORMAT_R8G8_UNORM);
		CHECK_FORMAT(FORMAT_R8G8_UINT);
		CHECK_FORMAT(FORMAT_R8G8_SNORM);
		CHECK_FORMAT(FORMAT_R8G8_SINT);
		CHECK_FORMAT(FORMAT_R16_TYPELESS);
		CHECK_FORMAT(FORMAT_R16_FLOAT);
		CHECK_FORMAT(FORMAT_D16_UNORM);
		CHECK_FORMAT(FORMAT_R16_UNORM);
		CHECK_FORMAT(FORMAT_R16_UINT);
		CHECK_FORMAT(FORMAT_R16_SNORM);
		CHECK_FORMAT(FORMAT_R16_SINT);
		CHECK_FORMAT(FORMAT_R8_TYPELESS);
		CHECK_FORMAT(FORMAT_R8_UNORM);
		CHECK_FORMAT(FORMAT_R8_UINT);
		CHECK_FORMAT(FORMAT_R8_SNORM);
		CHECK_FORMAT(FORMAT_R8_SINT);
		CHECK_FORMAT(FORMAT_A8_UNORM);
		CHECK_FORMAT(FORMAT_R1_UNORM);
		CHECK_FORMAT(FORMAT_R9G9B9E5_SHAREDEXP);
		CHECK_FORMAT(FORMAT_R8G8_B8G8_UNORM);
		CHECK_FORMAT(FORMAT_G8R8_G8B8_UNORM);
		CHECK_FORMAT(FORMAT_BC1_TYPELESS);
		CHECK_FORMAT(FORMAT_BC1_UNORM);
		CHECK_FORMAT(FORMAT_BC1_UNORM_SRGB);
		CHECK_FORMAT(FORMAT_BC2_TYPELESS);
		CHECK_FORMAT(FORMAT_BC2_UNORM);
		CHECK_FORMAT(FORMAT_BC2_UNORM_SRGB);
		CHECK_FORMAT(FORMAT_BC3_TYPELESS);
		CHECK_FORMAT(FORMAT_BC3_UNORM);
		CHECK_FORMAT(FORMAT_BC3_UNORM_SRGB);
		CHECK_FORMAT(FORMAT_BC4_TYPELESS);
		CHECK_FORMAT(FORMAT_BC4_UNORM);
		CHECK_FORMAT(FORMAT_BC4_SNORM);
		CHECK_FORMAT(FORMAT_BC5_TYPELESS);
		CHECK_FORMAT(FORMAT_BC5_UNORM);
		CHECK_FORMAT(FORMAT_BC5_SNORM);
		CHECK_FORMAT(FORMAT_B5G6R5_UNORM);
		CHECK_FORMAT(FORMAT_B5G5R5A1_UNORM);
		CHECK_FORMAT(FORMAT_B8G8R8A8_UNORM);
		CHECK_FORMAT(FORMAT_B8G8R8X8_UNORM);
		CHECK_FORMAT(FORMAT_R10G10B10_XR_BIAS_A2_UNORM);
		CHECK_FORMAT(FORMAT_B8G8R8A8_TYPELESS);
		CHECK_FORMAT(FORMAT_B8G8R8A8_UNORM_SRGB);
		CHECK_FORMAT(FORMAT_B8G8R8X8_TYPELESS);
		CHECK_FORMAT(FORMAT_B8G8R8X8_UNORM_SRGB);
		CHECK_FORMAT(FORMAT_BC6H_TYPELESS);
		CHECK_FORMAT(FORMAT_BC6H_UF16);
		CHECK_FORMAT(FORMAT_BC6H_SF16);
		CHECK_FORMAT(FORMAT_BC7_TYPELESS);
		CHECK_FORMAT(FORMAT_BC7_UNORM);
		CHECK_FORMAT(FORMAT_BC7_UNORM_SRGB);
		CHECK_FORMAT(FORMAT_AYUV);
		CHECK_FORMAT(FORMAT_Y410);
		CHECK_FORMAT(FORMAT_Y416);
		CHECK_FORMAT(FORMAT_NV12);
		CHECK_FORMAT(FORMAT_P010);
		CHECK_FORMAT(FORMAT_P016);
		CHECK_FORMAT(FORMAT_420_OPAQUE);
		CHECK_FORMAT(FORMAT_YUY2);
		CHECK_FORMAT(FORMAT_Y210);
		CHECK_FORMAT(FORMAT_Y216);
		CHECK_FORMAT(FORMAT_NV11);
		CHECK_FORMAT(FORMAT_AI44);
		CHECK_FORMAT(FORMAT_IA44);
		CHECK_FORMAT(FORMAT_P8);
		CHECK_FORMAT(FORMAT_A8P8);
		CHECK_FORMAT(FORMAT_B4G4R4A4_UNORM);
		CHECK_FORMAT(FORMAT_P208);
		CHECK_FORMAT(FORMAT_V208);
		CHECK_FORMAT(FORMAT_V408);
		CHECK_FORMAT(FORMAT_FORCE_UINT);
		return (EFORMAT)0;

#undef CHECK_FORMAT
	}

	EBLEND_OP ParseBlendOp(const std::string& BlendOpStr)
	{
#define CHECK_BLEND_OP(x) if (BlendOpStr == #x) { return x; }

		CHECK_BLEND_OP(BLEND_OP_ADD);
		CHECK_BLEND_OP(BLEND_OP_SUBTRACT);
		CHECK_BLEND_OP(BLEND_OP_REV_SUBTRACT);
		CHECK_BLEND_OP(BLEND_OP_MIN);
		CHECK_BLEND_OP(BLEND_OP_MAX);
		return (EBLEND_OP)0;

#undef CHECK_BLEND_OP
	}

	ELOGIC_OP ParseLogicOp(const std::string& LogicOpStr)
	{
#define CHECK_LOGIC_OP(x) if (LogicOpStr == #x) { return x; }

		CHECK_LOGIC_OP(LOGIC_OP_CLEAR);
		CHECK_LOGIC_OP(LOGIC_OP_SET);
		CHECK_LOGIC_OP(LOGIC_OP_COPY);
		CHECK_LOGIC_OP(LOGIC_OP_COPY_INVERTED);
		CHECK_LOGIC_OP(LOGIC_OP_NOOP);
		CHECK_LOGIC_OP(LOGIC_OP_INVERT);
		CHECK_LOGIC_OP(LOGIC_OP_AND);
		CHECK_LOGIC_OP(LOGIC_OP_NAND);
		CHECK_LOGIC_OP(LOGIC_OP_OR);
		CHECK_LOGIC_OP(LOGIC_OP_NOR);
		CHECK_LOGIC_OP(LOGIC_OP_XOR);
		CHECK_LOGIC_OP(LOGIC_OP_EQUIV);
		CHECK_LOGIC_OP(LOGIC_OP_AND_REVERSE);
		CHECK_LOGIC_OP(LOGIC_OP_AND_INVERTED);
		CHECK_LOGIC_OP(LOGIC_OP_OR_REVERSE);
		CHECK_LOGIC_OP(LOGIC_OP_OR_INVERTED);
		return (ELOGIC_OP)0;

#undef CHECK_LOGIC_OP
	}

	ECOMPARISON_FUNCTION ParseComparisonFunction(const std::string& ComparisonFuncStr)
	{
#define CHECK_COMPARISON_FUNC(x) if (ComparisonFuncStr == #x) { return x; }

		CHECK_COMPARISON_FUNC(COMPARISON_FUNCTION_NEVER);
		CHECK_COMPARISON_FUNC(COMPARISON_FUNCTION_LESS);
		CHECK_COMPARISON_FUNC(COMPARISON_FUNCTION_EQUAL);
		CHECK_COMPARISON_FUNC(COMPARISON_FUNCTION_LESS_EQUAL);
		CHECK_COMPARISON_FUNC(COMPARISON_FUNCTION_GREATER);
		CHECK_COMPARISON_FUNC(COMPARISON_FUNCTION_NOT_EQUAL);
		CHECK_COMPARISON_FUNC(COMPARISON_FUNCTION_GREATER_EQUAL);
		CHECK_COMPARISON_FUNC(COMPARISON_FUNCTION_ALWAYS);
		return (ECOMPARISON_FUNCTION)0;

#undef CHECK_COMPARISON_FUNC
	}

	ESTENCIL_OP ParseStencilOp(const std::string StencilOpStr)
	{
#define CHECK_STENCIL_OP(x) if (StencilOpStr == #x) { return x; }

		CHECK_STENCIL_OP(STENCIL_OP_KEEP);
		CHECK_STENCIL_OP(STENCIL_OP_ZERO);
		CHECK_STENCIL_OP(STENCIL_OP_REPLACE);
		CHECK_STENCIL_OP(STENCIL_OP_INCR_SAT);
		CHECK_STENCIL_OP(STENCIL_OP_DECR_SAT);
		CHECK_STENCIL_OP(STENCIL_OP_INVERT);
		CHECK_STENCIL_OP(STENCIL_OP_INCR);
		CHECK_STENCIL_OP(STENCIL_OP_DECR);
		return (ESTENCIL_OP)0;

#undef CHECK_STENCIL_OP
	}

	EMULTISAMPLE_LEVEL ParseMultisampleLevel(const std::string& MultisampleLevelStr)
	{
#define CHECK_SAMPLELEVEL(x) if (MultisampleLevelStr == #x) { return x; }

		CHECK_SAMPLELEVEL(MULTISAMPLE_LEVEL_0);
		CHECK_SAMPLELEVEL(MULTISAMPLE_LEVEL_4X);
		CHECK_SAMPLELEVEL(MULTISAMPLE_LEVEL_8X);
		CHECK_SAMPLELEVEL(MULTISAMPLE_LEVEL_16X);
		return MULTISAMPLE_LEVEL_0;

#undef CHECK_SAMPLELEVEL
	}

	EPOLYGON_TYPE ParsePolygonType(const std::string& PolygonTypeStr)
	{
#define CHECK_POLY(x) if (PolygonTypeStr == #x) { return x; }

		CHECK_POLY(POLYGON_TYPE_POINTS);
		CHECK_POLY(POLYGON_TYPE_LINES);
		CHECK_POLY(POLYGON_TYPE_TRIANGLES);
		CHECK_POLY(POLYGON_TYPE_TRIANGLE_STRIPS);
		return (EPOLYGON_TYPE)0;

#undef CHECK_POLY
	}
}